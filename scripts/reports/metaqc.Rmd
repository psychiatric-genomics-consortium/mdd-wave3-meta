---
title: "PGC MDD3 sumstats QC checks for meta-analysis"
output:
    html_document:
        toc: true
        toc_depth: 2
---

```{r}
library(dplyr)
library(readr)
library(tidyr)
library(stringr)
library(ggplot2)
library(fdrtool)
library(corrplot)
```

# Sample sizes

```{r meta_sample_size}

meta_qc_align <- read_tsv(snakemake@input$meta_qc_align)
cohorts_mdd <- read_tsv(snakemake@input$cohorts_mdd)

cohorts_samples <- cohorts_mdd %>%
filter(Dataset != 'SUM') %>%
mutate(cohort=str_match(Dataset, "mdd_(.+)_eur")[,2])

meta_samples <- 
meta_qc_align %>%
filter(!cohort %in% c('MDD29', 'PGC')) %>%
bind_rows(cohorts_samples) %>%
group_by(cohort) %>%
summarize(Cases=sum(N_cases), Controls=sum(N_controls)) %>%
pivot_longer(Cases:Controls, names_to="MDD", values_to="N") %>%
arrange(desc(N))

cohort_order <-
meta_samples %>%
filter(MDD == 'Cases') %>%
arrange(desc(N)) %>%
pull(cohort)

ggplot(meta_samples, aes(x=0, y=0, color=MDD, size=N)) +
geom_point() +
facet_wrap(~factor(cohort, levels=cohort_order)) +
scale_size_area(max_size=33) +
theme_minimal() +
theme(axis.line=element_blank(),
  axis.text.x=element_blank(),
  axis.text.y=element_blank(),
  axis.ticks=element_blank(),
  axis.title.x=element_blank(),
  axis.title.y=element_blank())

```

# Reference panel alignment

Marker names were aligned to the meta-analysis reference panel and effect sizes were checked. SNPs with MAF < `r snakemake@params$maf` in the imputation reference panel and INFO < `r snakemake@params$info` in the cohort were removed.

```{r meta_qc_align}
meta_qc_align %>% print(n=Inf)
```

Median odds-ratios with standard error
```{r meta_qc_align_mean_OR}

ggplot(meta_qc_align %>%
       unite('cohort',
	          cohort, ancestries, release, 
			  sep="."),
	    aes(x=reorder(cohort, (4*N_cases*N_controls)/(N_cases + N_controls)),
		    y=median_or,
			ymax=exp(log(median_or)+median_SE),
		    ymin=exp(log(median_or)-median_SE))) +
geom_linerange() +
geom_point() +
coord_flip(ylim=c(0.8, 1.25))

```

Mean standard error versus effective sample size:
```{r meta_qc_align_Neff_SE}

ggplot(meta_qc_align %>%
	   unite('cohort',
			  cohort, ancestries, release, 
			  sep=".") %>%
	   mutate(Neff=(4*N_cases*N_controls)/(N_cases + N_controls)),
		aes(x=Neff, y=median_SE, label=cohort)) +
geom_text(size=2) +
scale_x_log10(breaks=c(1, 100, 1000, 5000, 10000, 50000, 100000, 500000))

```


# Genetic correlation with clinical cohorts

LDSC genetic correlations were calculated with the PGC `MDD29` clinical cohorts

```{r meta_qc_ldsc}
meta_qc_ldsc <-
read_table2(snakemake@input$meta_qc_ldsc) %>%
mutate(se.mdd2=as.numeric(str_remove_all(se.mdd2, "[\\(\\)]")),
 	   se.mdd29=as.numeric(str_remove_all(se.mdd29, "[\\(\\)]")),
	   gencov_se.mdd2=as.numeric(str_remove_all(gencov_se.mdd2, "[\\(\\)]")),
	   gencov_se.mdd29=as.numeric(str_remove_all(gencov_se.mdd29, "[\\(\\)]"))
	)
```
```{r metq_qc_ldsc_rg}
ggplot(meta_qc_ldsc, aes(x=reorder(paste(cohort, release), rg.mdd29), y=rg.mdd29, ymin=rg.mdd29-se.mdd29, ymax=rg.mdd29+se.mdd29)) +
geom_linerange() +
geom_point() +
coord_flip(ylim=c(0, 1.25))
```

Genetic covariance:

```{r metq_qc_ldsc_gcov}
ggplot(meta_qc_ldsc, aes(x=reorder(paste(cohort, release), gencov.mdd29), y=gencov.mdd29, ymin=gencov.mdd29-gencov_se.mdd29, ymax=gencov.mdd29+gencov_se.mdd29)) +
geom_linerange() +
geom_point() +
coord_flip()
```

# Genetic correlation with previous meta analysis

```{r metq_qc_ldsc_rg_mdd2}
ggplot(meta_qc_ldsc, aes(x=reorder(paste(cohort, release), rg.mdd2), y=rg.mdd2, ymin=rg.mdd2-se.mdd2, ymax=rg.mdd2+se.mdd2)) +
geom_linerange() +
geom_point() +
coord_flip(ylim=c(0, 1.25))
```

Genetic covariance:

```{r metq_qc_ldsc_gcov_mdd2}
ggplot(meta_qc_ldsc, aes(x=reorder(paste(cohort, release), gencov.mdd2), y=gencov.mdd2, ymin=gencov.mdd2-gencov_se.mdd2, ymax=gencov.mdd2+gencov_se.mdd2)) +
geom_linerange() +
geom_point() +
coord_flip()
```



# Genetic covariance intercepts

Pairwise LDSC genetic covariance intercepts between all cohorts

```{r meta_qc_ldsc_pairs}
meta_qc_ldsc_pairs <- read_tsv(snakemake@input$meta_qc_ldsc_pairs)

# calculate total sample sizes
meta_qc_samplesize <- meta_qc_align %>%
transmute(cohort, ancestries, release, N=N_cases+N_controls)

# sumstats appearing in MDD3 (exclude other
# sumstats like Wray 2018 that have had their 
# sumstats munged for other reasons)
meta_qc_ldsc_pairs_mdd3 <- meta_qc_ldsc_pairs  %>%
filter(!cohort1 %in% c('MDD29', 'PGC') & !cohort2 %in% c('MDD29', 'PGC')) %>%
left_join(meta_qc_samplesize %>% rename(cohortN1=N), by=c('cohort1'='cohort', 'subcohort1'='release', 'ancestry1'='ancestries')) %>%
left_join(meta_qc_samplesize %>% rename(cohortN2=N), by=c('cohort2'='cohort', 'subcohort2'='release', 'ancestry2'='ancestries'))

```

Histogram of intercepts

```{r meta_qc_ldcs_pairs_hist}

ggplot(meta_qc_ldsc_pairs_mdd3, aes(x=gcov_int)) +
geom_histogram()

```

Pairwise intercepts

```{r}



```

Show the largest and smallest intercepts. Exclude Wray2018 sumstats that are also in the mix. Calculate distance from 0 in standard deviation units to get an idea of the magnitude of departure from expectation relative to the other intercepts.

```{r meta_qc_ldsc_pairs_largest}
meta_qc_ldsc_pairs_mdd3 %>%
select(cohort1, subcohort1, cohort2, subcohort2, gcov_int) %>%
mutate(SDs=abs(gcov_int)/sd(gcov_int, na.rm=T)) %>%
arrange(desc(gcov_int))
```

```{r meta_qc_ldsc_pairs_smallest}
meta_qc_ldsc_pairs_mdd3 %>%
select(cohort1, subcohort1, cohort2, subcohort2, gcov_int) %>%
mutate(SDs=abs(gcov_int)/sd(gcov_int, na.rm=T)) %>%
arrange(gcov_int)
```

Estimate amount of sample overlap as $N_S = g_{\mathrm{cov}_\mathrm{int}}\sqrt{N_1N_2} / r_\mathrm{P}$, where $r_\mathrm{P}$ is the phenotypic correlation between the two MDD phenotype (assume $r_\mathrm{P} = 1$)

```{r meta_qc_ldsc_pairs_ns}
rP <- 1
meta_qc_ldsc_pairs_mdd3_ns <-
meta_qc_ldsc_pairs_mdd3 %>%
mutate(Ns_factor=sqrt(cohortN1*cohortN2)/rP) %>%
mutate(Ns=gcov_int*Ns_factor,
       Ns_l95=(gcov_int+qnorm(0.025)*gcov_int_se)*Ns_factor,
	   Ns_u95=(gcov_int+qnorm(0.975)*gcov_int_se)*Ns_factor,
	   chisq=gcov_int^2/gcov_int_se^2) %>%
filter(!is.na(chisq)) %>%
mutate(qval=fdrtool(pchisq(chisq, df=1, lower.tail=F), statistic='pvalue', plot=FALSE)$qval) %>%
select(cohort1, subcohort1, cohort2, subcohort2, cohortN1, cohortN2, chisq, qval, Ns, Ns_l95, Ns_u95) %>%
mutate(Ns_pct=100*Ns/(cohortN1+cohortN2))
```

Sort (largest-to-smallest) by sample overlap
```{r meta_qc_ldsc_pairs_ns_arrange}
meta_qc_ldsc_pairs_mdd3_ns %>%
arrange(desc(Ns)) %>%
select(-chisq, -qval, -Ns_pct)
```

Sort (largest-to-smallest) by percentage of overlap to combined sample size
```{r meta_qc_ldsc_pairs_nspct_arrange}
meta_qc_ldsc_pairs_mdd3_ns %>%
arrange(desc(Ns_pct)) %>%
select(-cohortN1, -cohortN2, -chisq, -qval)
```

Sort by $\chi^2$ (Wald) test statistics

```{r meta_qc_ldsc_pairs_wald_arrange}
meta_qc_ldsc_pairs_mdd3_ns %>%
arrange(desc(chisq)) %>%
select(-cohortN1, -cohortN2)
```

Test for heterogeniety in covariance intercepts. Calculate $w$, the inverse variance of each $g_\mathrm{covint}$ standard error, then calculate a weighted sum $\hat{g_\mathrm{covint}}$

```{r meta_qc_ldsc_pairs_q}

meta_qc_ldsc_pairs_mdd3 %>%
filter(!is.na(gcov_int)) %>%
mutate(w=1/gcov_int_se^2) %>%
mutate(gcov_int_hat=sum(w*gcov_int)/sum(w)) %>%
summarise(Q=sum(w*(gcov_int-gcov_int_hat)^2), k=n()) %>%
mutate(I2=(Q-(k-1))/Q)

```

There is thus some heterogeneity in genetic covariance intercepts. We also want to look at heterogeniety per-cohort. The LDSC intercepts were calculated for each unique pair of cohorts. Expand this table to have every ordering of each pair

```{r}

# get unique cohort names from name and ancestry columns
meta_qc_ldsc_pairs_mdd3_named <-
meta_qc_ldsc_pairs_mdd3 %>%
mutate(cohort1=paste(cohort1, subcohort1, ancestry1, sep='.'),
	   cohort2=paste(cohort2, subcohort2, ancestry2, sep='.')) %>%
mutate(pair_name=paste(cohort1, cohort2, sep=','))

# get all unique cohort names
cohorts <- unique(c(meta_qc_ldsc_pairs_mdd3_named$cohort1,
                    meta_qc_ldsc_pairs_mdd3_named$cohort2))

# ordered pairs of cohort we have data listings for
cohorts_pair_names <- unique(meta_qc_ldsc_pairs_mdd3_named$pair_name)

# create list of all pairs of cohorts
meta_qc_ldsc_pairs_mdd3_all <-
tibble(cohort1=cohorts, cohort2=cohorts) %>%
complete(cohort1, cohort2) %>%
filter(cohort1 != cohort2) %>%
mutate(pair_name12=paste(cohort1, cohort2, sep=','),
	   pair_name21=paste(cohort2, cohort1, sep=',')) %>%
mutate(pair_name=case_when(pair_name12 %in% cohorts_pair_names ~ pair_name12,
                           pair_name21 %in% cohorts_pair_names ~ pair_name21,
						   TRUE ~ NA_character_)) %>%
select(cohort1, cohort2, pair_name) %>%
left_join(meta_qc_ldsc_pairs_mdd3_named %>% select(pair_name, gcov_int, gcov_int_se), by='pair_name')


```

Calculate $Q$ and $I^2$ for each cohort

```{r}
meta_qc_ldsc_pairs_mdd3_all_het <-
meta_qc_ldsc_pairs_mdd3_all %>%
group_by(cohort1) %>%
filter(!is.na(gcov_int)) %>%
mutate(w=1/gcov_int_se^2) %>%
mutate(gcov_int_hat=sum(w*gcov_int)/sum(w)) %>%
summarise(Q=sum(w*(gcov_int-gcov_int_hat)^2), k=n()) %>%
mutate(I2=(Q-(k-1))/Q) %>%
arrange(desc(I2))
meta_qc_ldsc_pairs_mdd3_all_het %>%
as.data.frame()
```

```{r plot_cohort_gcov_int}

# find range to fit all gcov_int values
gcov_int_min <- min(with(meta_qc_ldsc_pairs_mdd3, gcov_int-gcov_int_se), na.rm=TRUE)
gcov_int_max <- max(with(meta_qc_ldsc_pairs_mdd3, gcov_int+gcov_int_se), na.rm=TRUE)

ggplot(meta_qc_ldsc_pairs_mdd3_all %>% filter(cohort1 %in% meta_qc_ldsc_pairs_mdd3_all_het$cohort1[1:4]),
       aes(x=cohort2, y=gcov_int, ymin=gcov_int-gcov_int_se, ymax=gcov_int+gcov_int_se)) +
geom_point() +
geom_linerange() +
facet_grid(cols=vars(cohort1)) +
coord_flip(ylim=c(gcov_int_min-0.01, gcov_int_max+0.01))

```

```{r plot_cohort_gcov_int2}

ggplot(meta_qc_ldsc_pairs_mdd3_all %>% filter(cohort1 %in% meta_qc_ldsc_pairs_mdd3_all_het$cohort1[5:8]),
   aes(x=cohort2, y=gcov_int, ymin=gcov_int-gcov_int_se, ymax=gcov_int+gcov_int_se)) +
geom_point() +
geom_linerange() +
facet_grid(cols=vars(cohort1)) +
coord_flip(ylim=c(gcov_int_min-0.01, gcov_int_max+0.01))

```


## Clustering

Cluster based on similarity in genetic covariance intercepts.

```{r subcohorts}
# get a list of all cohort/subcohort names

subcohorts <- 
bind_rows(
select(meta_qc_ldsc_pairs_mdd3, cohort=cohort1, subcohort=subcohort1),
select(meta_qc_ldsc_pairs_mdd3, cohort=cohort2, subcohort=subcohort2)
) %>%
distinct()

```

 Make a matrix:

```{r gcov_int_mat}

cohort_names <- 
subcohorts %>%
transmute(cohort=paste(cohort, subcohort, sep='.')) %>%
pull(cohort)

gcov_int_mat <- diag(length(cohort_names))
dimnames(gcov_int_mat) <- list(cohort_names, cohort_names)

for(i in seq.int(nrow(meta_qc_ldsc_pairs_mdd3))) {
	cohort1 <- meta_qc_ldsc_pairs_mdd3$cohort1[i]
	cohort2 <- meta_qc_ldsc_pairs_mdd3$cohort2[i]
	subcohort1 <- meta_qc_ldsc_pairs_mdd3$subcohort1[i]
	subcohort2 <- meta_qc_ldsc_pairs_mdd3$subcohort2[i]
	cohort_name1 <- paste(cohort1, subcohort1, sep='.')
	cohort_name2 <- paste(cohort2, subcohort2, sep='.')

	# if gcov_int is NA, substitute 0 (average)

	gcov_int <- coalesce(meta_qc_ldsc_pairs_mdd3$gcov_int[i], 0)

	gcov_int_mat[cohort_name1,cohort_name2] <- gcov_int	
	gcov_int_mat[cohort_name2,cohort_name1] <- gcov_int
}

```

Convert intercepts into a dissimilarity matrix. For intercepts, `1 ==` same, `0 ==` average, `<0 ==` different. For dissimilarity, `0 ==` same and larger values `==` more dissimilar.

```{r gcov_int_dist, fig.width=6, fig.height=9}

plot(hclust(as.dist(1-gcov_int_mat)))

```

```{r gcov_int_mat_corr, fig.width=9, fig.height=9}

corrplot(gcov_int_mat, is.corr=FALSE, diag=FALSE)

```

## Genetic correlations


```{r rg_mat}

rg_mat <- diag(length(cohort_names))
dimnames(rg_mat) <- list(cohort_names, cohort_names)

for(i in seq.int(nrow(meta_qc_ldsc_pairs_mdd3))) {
	cohort1 <- meta_qc_ldsc_pairs_mdd3$cohort1[i]
	cohort2 <- meta_qc_ldsc_pairs_mdd3$cohort2[i]
	subcohort1 <- meta_qc_ldsc_pairs_mdd3$subcohort1[i]
	subcohort2 <- meta_qc_ldsc_pairs_mdd3$subcohort2[i]
	cohort_name1 <- paste(cohort1, subcohort1, sep='.')
	cohort_name2 <- paste(cohort2, subcohort2, sep='.')

	# if rg is NA, substitute 0 (average)

	rg <- meta_qc_ldsc_pairs_mdd3$rg[i]

	rg_mat[cohort_name1,cohort_name2] <- rg	
	rg_mat[cohort_name2,cohort_name1] <- rg
}

```

```{r rg_mat_corr, fig.width=9, fig.height=9}

rg_mat_1 <- rg_mat
rg_mat_1[which(rg_mat_1 > 1)] <- 1
rg_mat_1[which(rg_mat_1 < -1)] <- -1

has_rg_idx <- rowSums(!is.na(rg_mat_1)) > 1

corrplot(rg_mat_1[has_rg_idx,has_rg_idx], na.label='.')


```

